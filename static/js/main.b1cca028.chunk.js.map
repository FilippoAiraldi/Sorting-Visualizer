{"version":3,"sources":["SortingVisualizer/Body/ArrayBar.jsx","SortingVisualizer/Constants.js","SortingVisualizer/Algorithms/Algorithms.js","SortingVisualizer/Body/Body.jsx","SortingVisualizer/ToolBar/ToolBar.jsx","SortingVisualizer/SortingVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["ArrayBar","props","barRef","React","createRef","color","this","current","style","backgroundColor","h","height","parseFloat","ref","className","width","Component","CONSTS","MIN_BARS","MAX_BARS","INIT_BARS","Math","round","STANDARD_COLOR","COMPARED_COLOR","SWAPPED_COLOR","SORTED_COLOR","PIVOT_COLOR","MIN_ANIMATION_SPEED","MAX_ANIMATION_SPEED","INIT_ANIMATION_SPEED","_baseAnimationSpeed","undefined","getBaseAnimationSpeed","x","exp","_speedControl","updateAnimationSpeed","baseInterval","multiplier","document","getElementsByName","p","minp","maxp","log_v","log","getAnimationSpeedMultiplier","valueAsNumber","invokeSortingAlgorithm","method","v","a","bubbleSort","cocktailSort","oddEvenSort","combSort","selectionSort","insertionSort","gnomeSort","cycleSort","shellSort","treeSort","bogoSort","slowSort","heapSort","strandSort","stoogeSort","beadSort","pancakeSort","pigeonholeSort","radixSort","quickSort","mergeSort","coloringAll","sleep","N","length","unsorted","i","stopRequest","isRequested","requestHandled","getHeight","swap","colorAllSorted","beginIdx","endIdx","newBeginIdx","newEndIdx","range","odd","sorted","base","gap","shrink","floor","minIdx","j","tmp","setHeight","max_i","max","gaps","push","reverse","insert","inOrderTraversal","node","left","sortedIdx","val","right","idx","barIdx","Node","root","map","b","shuffle","isSorted","random","slowSortHelper","m","MaxHeap","start","end","rootIdx","_leftChild","childIdx","swapIdx","n","siftDown","_parent","heapify","strandSortHelper","inputIdx","forEach","setColor","outIdx","sublistIdx","shift","splice","cnt","subEnd","outStart","heightsCopy","stoogeSortHelper","t","maxHeight","transposed","Array","fill","sum","_","maxIdx","maxVal","newSlice","slice","minVal","min","holes","size","count","getRandomColor","hole","move","quickSortHelper","pivotIdx","pivot","newStart","newEnd","merge","mergeSortHelper","mid","start2","requestStop","ms","Promise","resolve","setTimeout","indeces","permanent","interval","filter","old_colors","getColor","from","Body","state","array","numberOfBars","barsRefs","setNumberOfBars","setState","generateBars","arr","randomFromInterval","controls","c","disabled","sortingCompleted","r","w","key","instance","roundToDigit","multipler","pow","ToolBar","selectRef","isSorting","idle","name","type","defaultValue","onChange","e","handleRangeChanged","target","value","label","fontSize","onClick","url","options","selectedIndex","window","open","textAlign","startSortActivated","stopSortActivated","SortingVisualizer","bodyRef","toolBarRef","sortArray","stopSorting","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.b1cca028.chunk.js","sourcesContent":["import React from 'react'\nimport './ArrayBar.css'\n\nexport default class ArrayBar extends React.Component {\n    constructor(props) {\n        super(props)\n        this.barRef = React.createRef();\n    }\n\n    setColor(color) {\n        this.barRef.current.style.backgroundColor = color;\n    }\n\n    getColor() {\n        return this.barRef.current.style.backgroundColor;\n    }\n\n    setHeight(h) {\n        this.barRef.current.style.height = `${h}%`;\n    }\n\n    getHeight() {\n        return parseFloat(this.barRef.current.style.height);\n    }\n\n    render() {\n        return (\n            <div\n                ref={this.barRef}\n                className=\"array-bar\"\n                style={{\n                    height: `${this.props.height}%`,\n                    width: `${this.props.width}%`\n                }}\n            />\n        );\n    }\n}","// modifiable constants \nlet min_bars = 3;                       // minimum number of bars in the body\nlet max_bars = 250;                     // maximum number of bars in the body\n\nlet standard_color = \"#2C32E0\";         // standard color for a bar\nlet compared_color = \"#FFC30F\";         // color of bars under comparison\nlet swapped_color = \"#C70039\";          // color of swapped bars\nlet pivot_color = \"#FF5733\";            // color of bars acting as pivots\nlet sorted_color = \"#581845\";           // color of sorted/processed bars \n/* let compared_color = \"lightblue\";    // color of bars under comparison\nlet swapped_color = \"darkred\";          // color of swapped bars\nlet sorted_color = \"darkorange\";        // color of sorted bars\nlet pivot_color = \"green\";              // color of bars acting as pivots */\n\n\nlet min_animation_speed = 0.1;          // min speed multiplier for animations\nlet max_animation_speed = 10.0;         // max speed multiplier for animations\n\n// ---------------------------------------------------------------------------\n// ---------------------------------------------------------------------------\n// ---------------------------------------------------------------------------\n\n// dont modify objects and functions below\nexport const CONSTS = {\n    MIN_BARS: min_bars,\n    MAX_BARS: max_bars,\n    INIT_BARS: Math.round((max_bars + min_bars) / 2),\n\n    STANDARD_COLOR: standard_color,\n    COMPARED_COLOR: compared_color,\n    SWAPPED_COLOR: swapped_color,\n    SORTED_COLOR: sorted_color,\n    PIVOT_COLOR: pivot_color,\n\n    MIN_ANIMATION_SPEED: 0,\n    MAX_ANIMATION_SPEED: 100,\n    INIT_ANIMATION_SPEED: 50\n};\n\n// Computes once, and then returns, the base animation \n// speed given x number of bars\nvar _baseAnimationSpeed = undefined;\nexport function getBaseAnimationSpeed(x) {\n    if (_baseAnimationSpeed !== undefined) {\n        return _baseAnimationSpeed;\n    }\n    _baseAnimationSpeed = 376.3307 - (8.541539 / 0.02292797) * (1 - Math.exp(-0.02292797 * x));\n    return _baseAnimationSpeed;\n}\n\n// Computes the animation speed multiplier on the logarithmic\n// scale of the speed range input\nfunction getAnimationSpeedMultiplier(p) {\n    let minp = CONSTS.MIN_ANIMATION_SPEED;\n    let maxp = CONSTS.MAX_ANIMATION_SPEED;\n\n    let minv = min_animation_speed;\n    let maxv = max_animation_speed;\n\n    let log_v = Math.log(minv) + (p - minp) * (Math.log(maxv) - Math.log(minv)) / (maxp - minp);\n    return Math.exp(log_v);\n}\n\n// Computes the spped multiplier and update the base animation\n// interval with the found multiplier\nvar _speedControl = undefined;\nexport function updateAnimationSpeed(baseInterval) {\n    let multiplier = 1;\n\n    if (_speedControl === undefined) {\n        _speedControl = document.getElementsByName(\"speed-control\")[0];\n    }\n\n    if (_speedControl !== undefined) {\n        multiplier = getAnimationSpeedMultiplier(_speedControl.valueAsNumber);\n        if (multiplier <= 0) {\n            multiplier = 1;\n        }\n    }\n\n    return baseInterval / multiplier;\n}","\nimport { CONSTS, getBaseAnimationSpeed, updateAnimationSpeed } from '../Constants.js'\n\n\n\nexport async function invokeSortingAlgorithm(method, v) {\n    // sort array based on method\n    switch (method) {\n        case \"bubble_sort\": await bubbleSort(v); break;\n        case \"cocktail_sort\": await cocktailSort(v); break;\n        case \"oddeven_sort\": await oddEvenSort(v); break;\n        case \"comb_sort\": await combSort(v); break;\n        case \"selection_sort\": await selectionSort(v); break;\n        case \"insertion_sort\": await insertionSort(v); break;\n        case \"gnome_sort\": await gnomeSort(v); break;\n        case \"cycle_sort\": await cycleSort(v); break;\n        case \"sheel_sort\": await shellSort(v); break;\n        case \"tree_sort\": await treeSort(v); break;\n        case \"bogo_sort\": await bogoSort(v); break;\n        case \"slow_sort\": await slowSort(v); break;\n        case \"heap_sort\": await heapSort(v); break;\n        case \"strand_sort\": await strandSort(v); break;\n        case \"stooge_sort\": await stoogeSort(v); break;\n        case \"bead_sort\": await beadSort(v); break;\n        case \"pancake_sort\": await pancakeSort(v); break;\n        case \"pigeonhole_sort\": await pigeonholeSort(v); break;\n        case \"radix_sort\": await radixSort(v); break;\n        case \"quick_sort\": await quickSort(v); break;\n        case \"merge_sort\": await mergeSort(v); break;\n        default: break;\n    }\n\n    // wait for all colorings to be executed\n    while (coloringAll) { await sleep(2); }\n}\n\n\n\nasync function bubbleSort(v) {\n    // initialize\n    let N = v.length;\n    let unsorted;\n\n    // start looping\n    do {\n        unsorted = false;\n        for (let i = 1; i < N; ++i) {\n            // check if a stop was requested\n            if (stopRequest.isRequested) {\n                stopRequest.requestHandled();\n                return;\n            }\n\n            // color bars under comparison\n            await color(v, [i - 1, i], CONSTS.COMPARED_COLOR);\n\n            if (v[i - 1].getHeight() > v[i].getHeight()) {\n                swap(v, i - 1, i);\n                unsorted = true;\n                // color swapped bars\n                await color(v, [i - 1, i], CONSTS.SWAPPED_COLOR);\n            }\n        }\n        N--;\n        // color sorted bar (always last one pointed by N)\n        await color(v, [N], CONSTS.SORTED_COLOR, true);\n    }\n    while (unsorted);\n\n    // color all bars as sorted\n    colorAllSorted(v);\n}\n\nasync function cocktailSort(v) {\n    // initialize\n    let N = v.length;\n    let beginIdx = 0;\n    let endIdx = N - 2;\n\n    // start sorting\n    while (beginIdx <= endIdx) {\n        let newBeginIdx = endIdx;\n        let newEndIdx = beginIdx;\n\n        for (let i = beginIdx; i <= endIdx; ++i) {\n            // check if a stop was requested\n            if (stopRequest.isRequested) {\n                stopRequest.requestHandled();\n                return;\n            }\n\n            // color bars under comparison\n            await color(v, [i, i + 1], CONSTS.COMPARED_COLOR);\n\n            if (v[i].getHeight() > v[i + 1].getHeight()) {\n                swap(v, i, i + 1);\n                newEndIdx = i;\n                // color swapped bars\n                await color(v, [i, i + 1], CONSTS.SWAPPED_COLOR);\n            }\n        }\n        endIdx = newEndIdx - 1;\n        // color sorted bars (all after newEndIdx)\n        await color(v, range(newEndIdx + 1, N), CONSTS.SORTED_COLOR, true);\n\n        for (let i = endIdx; i >= beginIdx; --i) {\n            // check if a stop was requested\n            if (stopRequest.isRequested) {\n                stopRequest.requestHandled();\n                return;\n            }\n\n            // color bars under comparison\n            await color(v, [i, i + 1], CONSTS.COMPARED_COLOR);\n\n            if (v[i].getHeight() > v[i + 1].getHeight()) {\n                swap(v, i, i + 1);\n                newBeginIdx = i;\n                // color swapped bars\n                await color(v, [i, i + 1], CONSTS.SWAPPED_COLOR);\n            }\n        }\n        beginIdx = newBeginIdx + 1;\n        // color sorted bars (all before newBeginIdx)\n        await color(v, range(0, newBeginIdx + 1), CONSTS.SORTED_COLOR, true);\n    }\n\n    // color all bars as sorted\n    colorAllSorted(v);\n}\n\nasync function oddEvenSort(v) {\n    // initialize\n    let N = v.length;\n    let odd = false;\n    let sorted = [false, false]; // one for even, one for odd\n\n    // start looping; exit iff both even and odd sets are sorted \n    while (!sorted[0] || !sorted[1]) {\n        let base = !odd ? 0 : 1;\n        sorted[base] = true;\n        odd = !odd\n\n        for (let i = base; i < N - 1; i += 2) {\n            // check if a stop was requested\n            if (stopRequest.isRequested) {\n                stopRequest.requestHandled();\n                return;\n            }\n\n            // color bars under comparison\n            await color(v, [i, i + 1], CONSTS.COMPARED_COLOR);\n\n            if (v[i].getHeight() > v[i + 1].getHeight()) {\n                swap(v, i, i + 1);\n                sorted[base] = false;\n                // color swapped bars\n                await color(v, [i, i + 1], CONSTS.SWAPPED_COLOR);\n            }\n        }\n    }\n\n    // color all bars as sorted\n    colorAllSorted(v);\n}\n\nasync function combSort(v) {\n    // initialize\n    let N = v.length;\n    let gap = N;\n    let shrink = 1.3;\n    let sorted = false;\n\n    while (!sorted) {\n        gap = Math.floor(gap / shrink);\n        if (gap <= 1) {\n            gap = 1;\n            sorted = true;\n        }\n\n        let i = 0;\n        while (i + gap < N) {\n            // check if a stop was requested\n            if (stopRequest.isRequested) {\n                stopRequest.requestHandled();\n                return;\n            }\n\n            // color bars under comparison\n            await color(v, [i, i + gap], CONSTS.COMPARED_COLOR);\n\n            if (v[i].getHeight() > v[i + gap].getHeight()) {\n                swap(v, i, i + gap);\n                sorted = false;\n                // color swapped bars\n                await color(v, [i, i + gap], CONSTS.SWAPPED_COLOR);\n            }\n            i++;\n        }\n    }\n\n    // color all bars as sorted\n    colorAllSorted(v);\n}\n\nasync function selectionSort(v) {\n    // initialize\n    let N = v.length;\n\n    // start looping\n    for (let i = 0; i < N - 1; ++i) {\n        let minIdx = i;\n        for (let j = i + 1; j < N; ++j) {\n            // check if a stop was requested\n            if (stopRequest.isRequested) {\n                stopRequest.requestHandled();\n                return;\n            }\n\n            minIdx = v[j].getHeight() < v[minIdx].getHeight() ? j : minIdx;\n\n            // color bars under comparison\n            color(v, [minIdx, j], CONSTS.COMPARED_COLOR);\n            // color bar that will be swapped (not really a pivot..)\n            await color(v, [i], CONSTS.PIVOT_COLOR);\n        }\n\n        if (minIdx !== i) {\n            swap(v, i, minIdx);\n            // color swapped bars\n            await color(v, [i, minIdx], CONSTS.SWAPPED_COLOR);\n        }\n\n        // color sorted bar\n        await color(v, [i], CONSTS.SORTED_COLOR, true);\n    }\n\n    // color all bars as sorted\n    colorAllSorted(v);\n}\n\nasync function insertionSort(v) {\n    // initialize\n    let N = v.length;\n    color(v, [0], CONSTS.SORTED_COLOR, true);\n\n    // start looping\n    for (let i = 1; i < N; ++i) {\n        let tmp = v[i].getHeight();\n        let j = i - 1;\n\n        while (j >= 0 && v[j].getHeight() > tmp) {\n            // check if a stop was requested\n            if (stopRequest.isRequested) {\n                stopRequest.requestHandled();\n                return;\n            }\n\n            // color bar that will be inserted (not really a pivot..)\n            color(v, [i], CONSTS.PIVOT_COLOR);\n            // color moving bar under comparison\n            await color(v, [j], CONSTS.COMPARED_COLOR);\n\n            v[j + 1].setHeight(v[j].getHeight());\n            j--;\n        }\n\n        v[j + 1].setHeight(tmp);\n\n        // color swapped bars\n        await color(v, [j + 1, i], CONSTS.SWAPPED_COLOR);\n\n        // color sorted bar\n        await color(v, [i], CONSTS.SORTED_COLOR, true);\n    }\n\n    // color all bars as sorted\n    colorAllSorted(v);\n}\n\nasync function gnomeSort(v) {\n    // initialize \n    let N = v.length;\n    let i = 0;\n    let max_i = 0;\n\n    // start looping\n    while (i < N) {\n        // check if a stop was requested\n        if (stopRequest.isRequested) {\n            stopRequest.requestHandled();\n            return;\n        }\n\n        max_i = Math.max(max_i, i);\n        // color sorted bar\n        color(v, [max_i], CONSTS.SORTED_COLOR, true);\n        // color moving bar under comparison\n        await color(v, [i], CONSTS.COMPARED_COLOR);\n\n        if (i === 0 || v[i].getHeight() >= v[i - 1].getHeight()) {\n            i++;\n        }\n        else {\n            swap(v, i - 1, i);\n            i--;\n        }\n    }\n\n    // color all bars as sorted\n    colorAllSorted(v);\n}\n\nasync function cycleSort(v) {\n    // initialize \n    let N = v.length;\n\n    for (let i = 0; i < N - 1; ++i) {\n        let h = v[i].getHeight();\n\n        let p = i;\n        for (let j = i + 1; j < N; ++j) {\n            // check if a stop was requested\n            if (stopRequest.isRequested) {\n                stopRequest.requestHandled();\n                return;\n            }\n\n            // color moving bar under comparison (+ 1 avoids problems with colors overlapping)\n            color(v, [p + 1, j], CONSTS.COMPARED_COLOR);\n            // color bar that will be counted (not really a pivot..)\n            await color(v, [i], CONSTS.PIVOT_COLOR);\n\n            if (v[j].getHeight() < h) {\n                p++;\n            }\n        }\n\n        if (p === i) continue;\n\n        while (h === v[p].getHeight()) p++;\n\n        let tmp = v[p].getHeight();\n        v[p].setHeight(h);\n        h = tmp;\n        // color swapped bars\n        await color(v, [i, p], CONSTS.SWAPPED_COLOR);\n        // color sorted bar\n        color(v, [p], CONSTS.SORTED_COLOR, true);\n\n        while (p !== i) {\n            p = i;\n            for (let j = i + 1; j < N; ++j) {\n                // check if a stop was requested\n                if (stopRequest.isRequested) {\n                    stopRequest.requestHandled();\n                    return;\n                }\n                // color moving bar under comparison (+ 1 avoids problems with colors overlapping)\n                color(v, [p + 1, j], CONSTS.COMPARED_COLOR);\n                // color bar that will be counted (not really a pivot..)\n                await color(v, [i], CONSTS.PIVOT_COLOR);\n\n                if (v[j].getHeight() < h) {\n                    p++;\n                }\n            }\n\n            while (h === v[p].getHeight()) p++;\n\n            tmp = v[p].getHeight();\n            v[p].setHeight(h);\n            h = tmp;\n            // color swapped bars\n            await color(v, [i, p], CONSTS.SWAPPED_COLOR);\n            // color sorted bar\n            color(v, [p], CONSTS.SORTED_COLOR, true);\n        }\n    }\n\n    // color all bars as sorted\n    colorAllSorted(v);\n}\n\nasync function shellSort(v) {\n    // initialize\n    let N = v.length;\n\n    // compute optimal gaps\n    let gaps = [1];\n    for (let i = 2; gaps[gaps.length - 1] <= N; ++i) {\n        gaps.push(Math.round(0.8552601 * Math.exp(0.8386519 * i) - 0.5908367));\n    }\n    gaps.reverse();\n\n    for (const gap of gaps) {\n        for (let i = gap; i < N; ++i) {\n            // check if a stop was requested\n            if (stopRequest.isRequested) {\n                stopRequest.requestHandled();\n                return;\n            }\n\n            // color base bar\n            await color(v, [i], CONSTS.PIVOT_COLOR, true);\n\n            let tmp = v[i].getHeight();\n            let j;\n            for (j = i; j >= gap && v[j - gap].getHeight() > tmp; j -= gap) {\n                // check if a stop was requested\n                if (stopRequest.isRequested) {\n                    stopRequest.requestHandled();\n                    return;\n                }\n\n                // color moving bar under comparison\n                await color(v, [j], CONSTS.COMPARED_COLOR);\n                v[j].setHeight(v[j - gap].getHeight());\n            }\n\n            // color modified bar\n            if (gap !== 1) {\n                await color(v, [j], CONSTS.SWAPPED_COLOR);\n            } else {\n                await color(v, range(0, j + 1), CONSTS.SORTED_COLOR, true);\n            }\n            v[j].setHeight(tmp);\n\n            // color base bar back to normal\n            color(v, [i], CONSTS.STANDARD_COLOR, true);\n        }\n\n        if (gap === 1)\n            color(v, [N - 1], CONSTS.SORTED_COLOR, true);\n    }\n\n    // color all bars as sorted\n    colorAllSorted(v);\n}\n\nasync function treeSort(v) {\n    class Node {\n        constructor(x, idx) {\n            this.val = x;\n            this.barIdx = idx;\n            this.left = null;\n            this.right = null;\n        }\n    }\n\n    async function insert(node, val, idx) {\n        // color bar that has to be inserted\n        await color(v, [node.barIdx], CONSTS.COMPARED_COLOR);\n\n        if (val < node.val) {\n            if (node.left === null) {\n                // color bar that has been finally inserted\n                await color(v, [node.barIdx], CONSTS.SWAPPED_COLOR);\n                node.left = new Node(val, idx);\n            }\n            else\n                await insert(node.left, val, idx);\n        }\n        else {\n            if (node.right === null) {\n                // color bar that has been finally inserted\n                await color(v, [node.barIdx], CONSTS.SWAPPED_COLOR);\n                node.right = new Node(val, idx);\n            }\n            else\n                await insert(node.right, val, idx);\n        }\n    }\n\n    let sortedIdx = 0;\n    async function inOrderTraversal(node) {\n        // check if a stop was requested\n        if (stopRequest.isRequested) return;\n        // in this case, the request is not handled as it is \n        // embedded in a recursive function. It will be handled\n        // at the end of the calling function.\n\n        if (node === null) return;\n        await inOrderTraversal(node.left);\n\n        v[sortedIdx].setHeight(node.val);\n        // color sorted bar\n        await color(v, [sortedIdx++], CONSTS.SORTED_COLOR, true);\n\n        await inOrderTraversal(node.right);\n    }\n\n    // initialize root\n    let root = new Node(v[0].getHeight(), 0);\n    let h = v.map(b => b.getHeight());\n\n    // add each height to the binary tree\n    for (let i = 1; i < v.length; ++i) {\n        // check if a stop was requested\n        if (stopRequest.isRequested) {\n            stopRequest.requestHandled();\n            return;\n        }\n\n        // color bar to be inserted \n        await color(v, [i], CONSTS.PIVOT_COLOR, true);\n\n        // actually insert the bar\n        await insert(root, h[i], i);\n\n        // restore color of inserted bar\n        color(v, [i], CONSTS.STANDARD_COLOR, true);\n    }\n\n    // traverse tree in order\n    await inOrderTraversal(root);\n\n    // check for unhandled stop requests\n    if (stopRequest.isRequested) {\n        stopRequest.requestHandled();\n        return;\n    }\n\n    // color all bars as sorted\n    colorAllSorted(v);\n}\n\nasync function bogoSort(v) {\n    function shuffle(v) {\n        for (let i = v.length - 1; i > 0; i--) {\n            let j = Math.floor(Math.random() * (i + 1)); // random index from 0 to i\n            // [a[i], a[j]] = [a[j], a[i]];\n            swap(v, i, j);\n        }\n    }\n\n    function isSorted(v) {\n        for (let i = 0; i < v.length - 1; ++i) {\n            if (v[i].getHeight() > v[i + 1].getHeight()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    while (!isSorted(v)) {\n        // check if a stop was requested\n        if (stopRequest.isRequested) {\n            stopRequest.requestHandled();\n            return;\n        }\n        await sleep(500);\n        shuffle(v);\n    }\n\n    // color all bars as sorted\n    colorAllSorted(v);\n}\n\nasync function slowSort(v) {\n    async function slowSortHelper(v, i, j) {\n        // check if a stop was requested\n        if (stopRequest.isRequested) return;\n        // in this case, the request is not handled as it is \n        // embedded in a recursive function. It will be handled\n        // at the end of the calling function.\n\n        if (i >= j)\n            return;\n\n        let m = Math.floor((i + j) / 2);\n        // color limit bars\n        color(v, [m], CONSTS.COMPARED_COLOR);\n        await color(v, [i, j], CONSTS.PIVOT_COLOR);\n\n        // recursively call function on subarrays\n        await slowSortHelper(v, i, m);\n        await slowSortHelper(v, m + 1, j);\n\n        // color limit bars\n        await color(v, [i, m, j], CONSTS.SORTED_COLOR, true);\n\n        if (v[m].getHeight() > v[j].getHeight()) {\n            // color swapped bars\n            await color(v, [m, j], CONSTS.SWAPPED_COLOR);\n            swap(v, j, m);\n        }\n\n        await slowSortHelper(v, i, j - 1);\n    }\n\n    await slowSortHelper(v, 0, v.length - 1);\n\n    // check for unhandled stop requests\n    if (stopRequest.isRequested) {\n        stopRequest.requestHandled();\n        return;\n    }\n\n    // color all bars as sorted\n    colorAllSorted(v);\n}\n\nasync function heapSort(v) {\n    class MaxHeap {\n        static _parent = i => Math.floor((i - 1) / 2);\n        static _leftChild = i => 2 * i + 1;\n\n        static async siftDown(v, start, end) {\n            // color bar added to the heap\n            await color(v, [start], CONSTS.PIVOT_COLOR, true);\n\n            let rootIdx = start;\n            while (this._leftChild(rootIdx) <= end) {\n                // check if a stop was requested\n                if (stopRequest.isRequested) return;\n\n                let childIdx = this._leftChild(rootIdx);\n                let swapIdx = rootIdx;\n\n                if (v[swapIdx].getHeight() < v[childIdx].getHeight())\n                    swapIdx = childIdx;\n                if (childIdx + 1 <= end && v[swapIdx].getHeight() < v[childIdx + 1].getHeight())\n                    swapIdx = childIdx + 1;\n\n                if (swapIdx !== rootIdx) {\n                    swap(v, swapIdx, rootIdx);\n\n                    // color swapped bars\n                    await color(v, [swapIdx, rootIdx], CONSTS.SWAPPED_COLOR);\n\n                    rootIdx = swapIdx;\n                }\n                else {\n                    break;\n                }\n            }\n\n            // restore color\n            color(v, [start], CONSTS.STANDARD_COLOR, true);\n        }\n\n        static async heapify(v, n) {\n            for (let i = n - 1; i >= 0; --i) {\n                // check if a stop was requested\n                if (stopRequest.isRequested) return;\n\n                await this.siftDown(v, i, n - 1);\n            }\n        }\n    }\n\n    // initialize\n    let N = v.length;\n\n    // turn bars vector into a heap\n    await MaxHeap.heapify(v, N);\n\n    // start looping\n    for (let i = N - 1; i > 0; --i) {\n        // check for unhandled stop requests\n        if (stopRequest.isRequested) {\n            stopRequest.requestHandled();\n            return;\n        }\n\n        // swap heap head (i.e., remove max) and put it at the end\n        swap(v, 0, i);\n        // color swapped bars\n        await color(v, [0, i], CONSTS.SWAPPED_COLOR);\n        // last bar is now sorted\n        color(v, [i], CONSTS.SORTED_COLOR, true);\n\n        await MaxHeap.siftDown(v, 0, i - 1);\n    }\n\n    // check for unhandled stop requests\n    if (stopRequest.isRequested) {\n        stopRequest.requestHandled();\n        return;\n    }\n\n    // color all bars as sorted\n    colorAllSorted(v);\n}\n\nasync function strandSort(v) {\n    // initiliaze some variables for the recursive algorithm\n    let outIdx = [];\n    let cnt = 0;\n\n    // sorting helper function\n    async function strandSortHelper(inputIdx) {\n        if (inputIdx.length === 0) return;\n\n        // reset colors\n        v.forEach(b => b.setColor(CONSTS.STANDARD_COLOR));\n        color(v, outIdx, CONSTS.PIVOT_COLOR, true);\n\n        let sublistIdx = [];\n        sublistIdx.push(inputIdx.shift());\n\n        let i = 0;\n        for (let j = 0; j < inputIdx.length; ++j) {\n            // check if a stop was requested\n            if (stopRequest.isRequested) return;\n\n            let barIdx = inputIdx[j];\n            if (v[barIdx].getHeight() > v[sublistIdx[i]].getHeight()) {\n                inputIdx.splice(j, 1);\n                sublistIdx.push(barIdx);\n                j--;\n                i++;\n\n                // color sublist bars\n                await color(v, sublistIdx, CONSTS.COMPARED_COLOR, true);\n            }\n        }\n\n        if (cnt === 0) {\n            for (let j = 0; j < sublistIdx.length; ++j) {\n                // check if a stop was requested\n                if (stopRequest.isRequested) return;\n\n                outIdx.push(sublistIdx[j]);\n                cnt++;\n\n                // color outputs bars\n                await color(v, outIdx, CONSTS.PIVOT_COLOR, true);\n            }\n        }\n        else {\n            let subEnd = sublistIdx.length - 1;\n            let outStart = 0;\n            while (sublistIdx.length !== 0) {\n                // check if a stop was requested\n                if (stopRequest.isRequested) return;\n\n                if (v[sublistIdx[subEnd]].getHeight() > v[outIdx[outStart]].getHeight()) {\n                    outStart++;\n                }\n                else {\n                    let barIdx = sublistIdx[subEnd];\n                    outIdx.splice(outStart, 0, barIdx); // add item \n                    sublistIdx.splice(subEnd, 1);       // remove item\n                    subEnd--;\n                    outStart = 0;\n\n                    // color sublist bars and outputs\n                    color(v, sublistIdx, CONSTS.COMPARED_COLOR, true);\n                    await color(v, outIdx, CONSTS.PIVOT_COLOR, true);\n                }\n            }\n        }\n\n        await strandSortHelper(inputIdx);\n    }\n\n    // call sorting algo - result is in \"outIdx\" array, that\n    // contains the indeces of the bars in sorted order\n    await strandSortHelper(range(0, v.length));\n\n    let heightsCopy = v.map(b => b.getHeight());\n    let j = 0;\n    for (const i of outIdx) {\n        // check if a stop was requested\n        if (stopRequest.isRequested) break;\n\n        v[j++].setHeight(heightsCopy[i]);\n        // color sorted bar\n        await color(v, [j - 1], CONSTS.SORTED_COLOR, true);\n    }\n\n    // check for unhandled stop requests\n    if (stopRequest.isRequested) {\n        stopRequest.requestHandled();\n        return;\n    }\n\n    // color all bars as sorted\n    colorAllSorted(v);\n}\n\nasync function stoogeSort(v) {\n    async function stoogeSortHelper(a, i, j) {\n        if (i >= j) return;\n\n        // check if a stop was requested\n        if (stopRequest.isRequested) return;\n\n        // color compared bars \n        await color(v, [i, j], CONSTS.COMPARED_COLOR);\n\n        if (a[i].getHeight() > a[j].getHeight()) {\n            swap(v, i, j);\n\n            // color swapped bars\n            await color(v, [i, j], CONSTS.SWAPPED_COLOR);\n        }\n        if ((j - i + 1) > 2) {\n            let t = Math.floor((j - i + 1) / 3);\n            await stoogeSortHelper(a, i, j - t);\n            await stoogeSortHelper(a, i + t, j);\n            await stoogeSortHelper(a, i, j - t);\n        }\n    }\n\n    // start sorting\n    await stoogeSortHelper(v, 0, v.length - 1);\n\n    // check for unhandled stop requests\n    if (stopRequest.isRequested) {\n        stopRequest.requestHandled();\n        return;\n    }\n\n    // color all bars as sorted\n    colorAllSorted(v);\n}\n\nasync function beadSort(v) {\n    let maxHeight = 0;\n    for (let i = 0; i < v.length; ++i) {\n        // check if a stop was requested\n        if (stopRequest.isRequested) {\n            stopRequest.requestHandled();\n            return;\n        }\n\n        // color compared bar\n        await color(v, [i], CONSTS.COMPARED_COLOR);\n        if (maxHeight < v[i].getHeight()) {\n            maxHeight = v[i].getHeight();\n\n            // color max bar (and overwrite previous)\n            color(v, range(0, i), CONSTS.STANDARD_COLOR, true);\n            await color(v, [i], CONSTS.PIVOT_COLOR, true);\n        }\n    }\n\n    let transposed = new Array(maxHeight).fill(0);\n    for (const b of v) {\n        range(0, b.getHeight()).forEach(i => transposed[i]++);\n    }\n\n    for (let i = v.length - 1; i >= 0; --i) {\n        // check if a stop was requested\n        if (stopRequest.isRequested) {\n            stopRequest.requestHandled();\n            return;\n        }\n\n        let sum = 0;\n        transposed.forEach(n => sum += n > 0 ? 1 : 0);\n        v[i].setHeight(sum);\n\n        // color sorted bar \n        await color(v, [i], CONSTS.SORTED_COLOR, true);\n\n        transposed.forEach((_, i) => transposed[i]--);\n    }\n\n    // color all bars as sorted\n    colorAllSorted(v);\n}\n\nasync function pancakeSort(v) {\n    for (let i = v.length - 1; i >= 1; --i) {\n        // check if a stop was requested\n        if (stopRequest.isRequested) {\n            stopRequest.requestHandled();\n            return;\n        }\n        // reset colors (apart for sorted bars) and color first as max\n        color(v, [0], CONSTS.PIVOT_COLOR, true);\n        await color(v, range(1, i), CONSTS.STANDARD_COLOR, true);\n\n        let maxIdx = 0;\n        let maxVal = v[0].getHeight();\n\n        for (let j = 1; j <= i; ++j) {\n            // check if a stop was requested\n            if (stopRequest.isRequested) {\n                stopRequest.requestHandled();\n                return;\n            }\n            // color compared bar\n            await color(v, [j], CONSTS.COMPARED_COLOR);\n\n            if (v[j].getHeight() > maxVal) {\n                maxVal = v[j].getHeight();\n                maxIdx = j;\n\n                // color max bar (and overwrite previous)\n                color(v, range(0, maxIdx), CONSTS.STANDARD_COLOR, true);\n                await color(v, [maxIdx], CONSTS.PIVOT_COLOR, true);\n            }\n        }\n\n        if (maxIdx === i) {\n            // color last unsorted bar (i-th) as now sorted\n            await color(v, [i], CONSTS.SORTED_COLOR, true);\n            continue;\n        }\n\n        let newSlice;\n        if (maxIdx > 0) {\n            // color bars that will be reversed\n            await color(v, range(0, maxIdx), CONSTS.COMPARED_COLOR, true);\n            await color(v, range(0, maxIdx), CONSTS.SWAPPED_COLOR, true);\n            v[0].setColor(CONSTS.PIVOT_COLOR);\n            v[maxIdx].setColor(CONSTS.SWAPPED_COLOR);\n\n            newSlice = v.map(b => b.getHeight()).slice(0, maxIdx + 1).reverse();\n            for (let j = 0; j <= maxIdx; ++j) {\n                // check if a stop was requested\n                if (stopRequest.isRequested) {\n                    stopRequest.requestHandled();\n                    return;\n                }\n\n                v[j].setHeight(newSlice[j]);\n            }\n\n            // remove color for reversed bars\n            await color(v, range(1, maxIdx + 1), CONSTS.COMPARED_COLOR, true);\n            await color(v, range(1, maxIdx + 1), CONSTS.STANDARD_COLOR, true);\n        }\n\n        // now max is at the beginning of array\n        await color(v, [0], CONSTS.PIVOT_COLOR, true);\n\n        // color bars that will be reversed\n        await color(v, range(1, i + 1), CONSTS.COMPARED_COLOR, true);\n        await color(v, range(1, i + 1), CONSTS.SWAPPED_COLOR, true);\n        v[i].setColor(CONSTS.PIVOT_COLOR);\n        v[0].setColor(CONSTS.SWAPPED_COLOR);\n\n        newSlice = v.map(b => b.getHeight()).slice(0, i + 1).reverse();\n        for (let j = 0; j <= i; ++j) {\n            // check if a stop was requested\n            if (stopRequest.isRequested) {\n                stopRequest.requestHandled();\n                return;\n            }\n\n            v[j].setHeight(newSlice[j]);\n        }\n\n        // remove color for reversed bars\n        await color(v, range(0, i), CONSTS.COMPARED_COLOR, true);\n        await color(v, range(0, i), CONSTS.STANDARD_COLOR, true);\n\n        // now max is at the back of unsorted bars; turn it into sorted\n        await color(v, [i], CONSTS.SORTED_COLOR, true);\n    }\n\n    // color all bars as sorted\n    v.forEach(b => b.setColor(CONSTS.SORTED_COLOR));\n}\n\nasync function pigeonholeSort(v) {\n    let N = v.length;\n    let minVal = v[0].getHeight();\n    let maxVal = minVal;\n    for (let i = 1; i < N; ++i) {\n        let val = v[i].getHeight();\n        minVal = Math.min(minVal, val);\n        maxVal = Math.max(maxVal, val);\n    }\n\n    let size = maxVal - minVal + 1;\n    let holes = range(0, size).map(function () {\n        return { count: 0, color: getRandomColor() };\n    });\n\n    for (let i = 0; i < N; ++i) {\n        // check if a stop was requested\n        if (stopRequest.isRequested) {\n            stopRequest.requestHandled();\n            return;\n        }\n\n        let h = v[i].getHeight() - minVal;\n        holes[h].count++;\n        await color(v, [i], holes[h].color, true);\n    }\n\n    let cnt = 0;\n    for (let i = 0; i < size; ++i) {\n        let hole = holes[i];\n        while (hole.count > 0) {\n            hole.count--;\n            v[cnt].setHeight(i + minVal);\n            await color(v, [cnt++], hole.color, true);\n        }\n    }\n\n    // color all bars as sorted\n    colorAllSorted(v);\n}\n\nasync function radixSort(v) {\n    // initialize\n    let N = v.length;\n\n    // start looping\n    for (let shift = 31; shift > (31 - 7); --shift) { // just need 7 bits (max is 100)\n        // check if a stop was requested\n        if (stopRequest.isRequested) {\n            stopRequest.requestHandled();\n            return;\n        }\n\n        let tmp = new Array(N);\n        let j = 0;\n        for (let i = 0; i < N; ++i) {\n            // check if a stop was requested\n            if (stopRequest.isRequested) {\n                stopRequest.requestHandled();\n                return;\n            }\n            await color(v, [i], CONSTS.COMPARED_COLOR);\n\n            let move = (v[i].getHeight() << shift) >= 0;\n            if (shift === 0 ? !move : move) {\n                tmp[j++] = v[i].getHeight();\n            }\n            else {\n                v[i - j].setHeight(v[i].getHeight());\n                await color(v, [i - j], CONSTS.SWAPPED_COLOR);\n            }\n        }\n\n        for (let i = j; i < N; ++i) {\n            tmp[i] = v[i - j].getHeight();\n            color(v, [i - j], CONSTS.PIVOT_COLOR);\n            await color(v, [i], CONSTS.COMPARED_COLOR);\n        }\n\n        for (let i = 0; i < N; ++i) {\n            v[i].setHeight(tmp[i]);\n            await color(v, [i], CONSTS.SWAPPED_COLOR);\n        }\n    }\n\n    // color all bars as sorted\n    colorAllSorted(v);\n}\n\nasync function quickSort(v) {\n    async function quickSortHelper(v, start, end) {\n        if (start >= end) return;\n\n        // check if a stop was requested\n        if (stopRequest.isRequested) return;\n\n        let pivotIdx = Math.floor((end + start) / 2);\n        let pivot = v[pivotIdx].getHeight();\n        // color pivot bar\n        await color(v, [pivotIdx], CONSTS.PIVOT_COLOR, true);\n\n        let newStart = start;\n        let newEnd = end;\n        while (newStart <= newEnd) {\n            // check if a stop was requested\n            if (stopRequest.isRequested) return;\n\n            while (v[newStart].getHeight() < pivot) {\n                // check if a stop was requested\n                if (stopRequest.isRequested) return;\n                // color bar under comparison\n                await color(v, [newStart], CONSTS.COMPARED_COLOR);\n                newStart++;\n            }\n\n            while (v[newEnd].getHeight() > pivot) {\n                // check if a stop was requested\n                if (stopRequest.isRequested) return;\n                // color bar under comparison\n                await color(v, [newEnd], CONSTS.COMPARED_COLOR);\n                newEnd--;\n            }\n\n            if (newStart <= newEnd) {\n                swap(v, newStart, newEnd);\n                // color swapped bars\n                await color(v, [newStart, newEnd], CONSTS.SWAPPED_COLOR);\n                newStart++;\n                newEnd--;\n            }\n\n        }\n\n        // restore color of pivot bar\n        color(v, [pivotIdx], CONSTS.STANDARD_COLOR, true);\n\n        await quickSortHelper(v, start, newEnd);\n        await quickSortHelper(v, newStart, end);\n    }\n\n    // actual sorting\n    await quickSortHelper(v, 0, v.length - 1);\n\n    // check for unhandled stop requests\n    if (stopRequest.isRequested) {\n        stopRequest.requestHandled();\n        return;\n    }\n\n    // color all bars as sorted\n    colorAllSorted(v);\n}\n\nasync function mergeSort(v) {\n    async function merge(v, start, mid, end) {\n        // check if a stop was requested\n        if (stopRequest.isRequested) return;\n\n        let start2 = mid + 1;\n        if (v[mid].getHeight() <= v[start2].getHeight()) return;\n\n        while (start <= mid && start2 <= end) {\n            // check if a stop was requested\n            if (stopRequest.isRequested) return;\n\n            if (v[start].getHeight() <= v[start2].getHeight()) {\n                start++;\n            }\n            else {\n                let tmp = v[start2].getHeight();\n                for (let i = start2; i !== start; --i) {\n                    // check if a stop was requested\n                    if (stopRequest.isRequested) return;\n\n                    swap(v, i, i - 1);\n\n                    // color swapped bars\n                    await color(v, [i, i - 1], CONSTS.SWAPPED_COLOR);\n                }\n                v[start].setHeight(tmp);\n                // color swapped bar\n                await color(v, [start], CONSTS.SWAPPED_COLOR);\n\n                start++;\n                mid++;\n                start2++;\n            }\n        }\n    }\n\n    async function mergeSortHelper(v, start, end) {\n        // check if a stop was requested\n        if (stopRequest.isRequested) return;\n\n        if (start >= end) return;\n\n        let mid = Math.floor((start + end) / 2);\n        // reset colors; color limit bars\n        v.forEach(b => b.setColor(CONSTS.STANDARD_COLOR));\n        color(v, [start, end], CONSTS.COMPARED_COLOR);\n        await color(v, [mid], CONSTS.PIVOT_COLOR);\n\n        // recursions\n        await mergeSortHelper(v, start, mid);\n        await mergeSortHelper(v, mid + 1, end);\n\n        // reset colors; color bars delimiting ranges to merge\n        v.forEach(b => b.setColor(CONSTS.STANDARD_COLOR));\n        color(v, [start, mid + 1, end], CONSTS.PIVOT_COLOR, true);\n        await merge(v, start, mid, end);\n    }\n\n    // actual sorting\n    await mergeSortHelper(v, 0, v.length - 1);\n\n    // check for unhandled stop requests\n    if (stopRequest.isRequested) {\n        stopRequest.requestHandled();\n        return;\n    }\n\n    // color all bars as sorted\n    colorAllSorted(v);\n}\n\n\n\nlet stopRequest = {\n    isRequested: false,\n    requestStop() { this.isRequested = true; },\n    requestHandled() { this.isRequested = false; },\n};\n\nexport function forceStop() {\n    stopRequest.requestStop();\n}\n\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction swap(v, a, b) {\n    let tmp = v[a].getHeight();\n    v[a].setHeight(v[b].getHeight());\n    v[b].setHeight(tmp);\n}\n\nasync function color(v, indeces, color, permanent = false) {\n    // applies the color to the bars in v whose index \n    // appears in indeces\n\n    // get the speed and its multiplier\n    let interval = updateAnimationSpeed(getBaseAnimationSpeed(v.length));\n\n    // filter out eventual out-of-bounds indeces \n    let N = v.length;\n    indeces = indeces.filter(i => i >= 0 && i < N);\n\n    // if permant, just apply the new color, wait and return\n    if (permanent) {\n        indeces.forEach(i => {\n            v[i].setColor(color);\n        });\n        await sleep(interval);\n    }\n    // if not permant, save previous color, wait, reapply previous color, and return\n    else {\n        let old_colors = indeces.map(i => v[i].getColor());\n        indeces.forEach(i => {\n            v[i].setColor(color);\n        });\n        await sleep(interval);\n        indeces.forEach((i, j) => {\n            v[i].setColor(old_colors[j]);\n        });\n    }\n}\n\nlet coloringAll = false;\nasync function colorAllSorted(v) {\n    coloringAll = true;\n\n    // color all bars as sorted\n    for (let i = 0; i < v.length; ++i) {\n        v[i].setColor(CONSTS.SORTED_COLOR);\n        // await color(v, [i], CONSTS.SORTED_COLOR, true);\n        await sleep(5);\n    }\n\n    coloringAll = false;\n}\n\nfunction getRandomColor() {\n    let letters = '0123456789ABCDEF';\n    let color = '#';\n    for (let i = 0; i < 6; i++) {\n        color += letters[Math.floor(Math.random() * 16)];\n    }\n    return color;\n}\n\nfunction range(start, end) {\n    // end not inclusive\n    let length = end - start;\n    return Array.from({ length }, (_, i) => start + i);\n}\n","import React from 'react'\r\nimport ArrayBar from './ArrayBar'\r\nimport { CONSTS } from '../Constants.js';\r\nimport { invokeSortingAlgorithm, forceStop } from '../Algorithms/Algorithms.js';\r\nimport './Body.css'\r\n\r\nexport default class Body extends React.Component {\r\n    constructor(props) {\r\n        super(props)\r\n        this.state = {\r\n            array: [],\r\n            numberOfBars: CONSTS.INIT_BARS\r\n        };\r\n\r\n        // an array of refs to each bar\r\n        this.barsRefs = new Array(CONSTS.MAX_BARS);\r\n    }\r\n\r\n    componentDidMount() {\r\n        // basically triggers the first rendering of the bars\r\n        this.setNumberOfBars(this.state.numberOfBars)\r\n    }\r\n\r\n    setNumberOfBars(n) {\r\n        this.setState({\r\n            array: this.generateBars(n),\r\n            numberOfBars: n\r\n        });\r\n    }\r\n\r\n    generateBars(n) {\r\n        let arr = [];\r\n        for (let i = 0; i < n; ++i)\r\n            arr.push(Math.round(Math.randomFromInterval(1, 100)));\r\n        return arr;\r\n        // arr.push(Math.roundToDigit(Math.randomFromInterval(1, 100), 2));\r\n    }\r\n\r\n    stopSorting() {\r\n        forceStop();\r\n    }\r\n\r\n    async sortArray(method) {\r\n        // disable sorting controls\r\n        let controls = document.getElementsByName(\"sort-control\");\r\n        controls.forEach(c => c.disabled = true);\r\n\r\n        // call the sorting algorithm (after filtering out null refs) \r\n        // corresponding to the method and wait for it to finish\r\n        let v = this.barsRefs.filter(ref => ref !== null);\r\n        if (v.length > 1) {\r\n            // color all bars as unsorted\r\n            v.forEach(b => b.setColor(CONSTS.STANDARD_COLOR));\r\n\r\n            // proceed with sorting\r\n            await invokeSortingAlgorithm(method, v);\r\n        }\r\n\r\n        // enable sorting controls\r\n        controls.forEach(c => c.disabled = false);\r\n\r\n        // fire that sorting is over\r\n        this.props.sortingCompleted();\r\n    }\r\n\r\n    render() {\r\n        // reset colors for all bars (that aren't null)\r\n        this.barsRefs.filter(r => r !== null).forEach(b => b.setColor(CONSTS.STANDARD_COLOR));\r\n\r\n        // compute width of each bar\r\n        const w = 100 / this.state.numberOfBars;\r\n\r\n        // render bars\r\n        return (\r\n            <div className=\"array-container\">\r\n                {\r\n                    this.state.array.map((h, i) => (\r\n                        <ArrayBar\r\n                            key={i}\r\n                            height={h}\r\n                            width={w}\r\n                            ref={(instance) => { this.barsRefs[i] = instance }}\r\n                        />\r\n                    ))\r\n                }\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nMath.randomFromInterval = function (min, max) {\r\n    // min and max inclusive\r\n    return (Math.random() * (max - min + 1) + min);\r\n}\r\n\r\nMath.roundToDigit = function (x, n) {\r\n    const multipler = Math.pow(10, n);\r\n    return Math.round(x * multipler) / multipler;\r\n}","import React from 'react'\r\nimport './ToolBar.css'\r\nimport { CONSTS } from '../Constants.js';\r\n\r\nexport default class ToolBar extends React.Component {\r\n    constructor(props) {\r\n        super(props)\r\n\r\n        this.state = {\r\n            selectRef: React.createRef(),\r\n            isSorting: false\r\n        };\r\n    }\r\n\r\n    sortingCompleted() {\r\n        this.setState({\r\n            selectRef: this.state.selectRef,\r\n            isSorting: false\r\n        });\r\n    }\r\n\r\n    render() {\r\n        let idle = !this.state.isSorting;\r\n        return (\r\n            <div className=\"centered-item tool-bar\">\r\n                <label\r\n                    className=\"centered-item text-box\">\r\n                    Number<br />of elements\r\n                </label>\r\n                <input\r\n                    name=\"sort-control\"\r\n                    type=\"range\"\r\n                    style={{ width: \"100px\" }}\r\n                    min={CONSTS.MIN_BARS}\r\n                    max={CONSTS.MAX_BARS}\r\n                    defaultValue={CONSTS.INIT_BARS}\r\n                    onChange={(e) => this.props.handleRangeChanged(e.target.value)} />\r\n\r\n                <div className=\"separator\" />\r\n\r\n                <label className=\"centered-item text-box\">Sorting<br />algorithm</label>\r\n                <select\r\n                    name=\"sort-control\"\r\n                    ref={this.state.selectRef}\r\n                    className=\"centered-item\">\r\n\r\n                    <optgroup label=\"Exchanging\">\r\n                        <option value=\"bubble_sort\">Bubble sort</option>\r\n                        <option value=\"cocktail_sort\">Cocktail sort</option>\r\n                        <option value=\"oddeven_sort\">Odd-even sort</option>\r\n                        <option value=\"gnome_sort\">Gnome sort</option>\r\n                        <option value=\"comb_sort\">Comb sort</option>\r\n                    </optgroup>\r\n                    <option style={{ fontSize: \"1pt\" }} disabled={true}>&nbsp;</option>\r\n\r\n                    <optgroup label=\"Insertion\">\r\n                        <option value=\"insertion_sort\">Insertion sort</option>\r\n                        <option value=\"cycle_sort\">Cycle sort</option>\r\n                        <option value=\"sheel_sort\">Shellsort</option>\r\n                        <option value=\"tree_sort\">Tree sort</option>\r\n                    </optgroup>\r\n                    <option style={{ fontSize: \"1pt\" }} disabled={true}>&nbsp;</option>\r\n\r\n                    <optgroup label=\"Selection\">\r\n                        <option value=\"selection_sort\">Selection sort</option>\r\n                        <option value=\"heap_sort\">Heap sort</option>\r\n                        <option value=\"strand_sort\">Strand sort</option>\r\n                    </optgroup>\r\n                    <option style={{ fontSize: \"1pt\" }} disabled={true}>&nbsp;</option>\r\n\r\n                    <optgroup label=\"Partitioning\">\r\n                        <option value=\"quick_sort\">Quicksort</option>\r\n                    </optgroup>\r\n                    <option style={{ fontSize: \"1pt\" }} disabled={true}>&nbsp;</option>\r\n\r\n                    <optgroup label=\"Merging\">\r\n                        <option value=\"merge_sort\">Merge sort</option>\r\n                    </optgroup>\r\n                    <option style={{ fontSize: \"1pt\" }} disabled={true}>&nbsp;</option>\r\n\r\n                    <optgroup label=\"Non-comparison\">\r\n                        <option value=\"pigeonhole_sort\">Pigeonhole sort</option>\r\n                        <option value=\"radix_sort\">Radix sort (LSD)</option>\r\n                    </optgroup>\r\n                    <option style={{ fontSize: \"1pt\" }} disabled={true}>&nbsp;</option>\r\n\r\n                    <optgroup label=\"Other\">\r\n                        <option value=\"bogo_sort\">Bogosort</option>\r\n                        <option value=\"slow_sort\">Slowsort</option>\r\n                        <option value=\"stooge_sort\">Stooge sort</option>\r\n                        <option value=\"bead_sort\">Bead sort</option>\r\n                        <option value=\"pancake_sort\">Pancake sort</option>\r\n                    </optgroup>\r\n                </select>\r\n\r\n                <button\r\n                    className=\"info-button\"\r\n                    onClick={() => {\r\n                        let url;\r\n                        let e = this.state.selectRef.current;\r\n                        switch (e.options[e.selectedIndex].value) {\r\n                            case \"bubble_sort\": url = \"https://en.wikipedia.org/wiki/Bubble_sort\"; break;\r\n                            case \"cocktail_sort\": url = \"https://en.wikipedia.org/wiki/Cocktail_shaker_sort\"; break;\r\n                            case \"oddeven_sort\": url = \"https://en.wikipedia.org/wiki/Odd%E2%80%93even_sort\"; break;\r\n                            case \"comb_sort\": url = \"https://en.wikipedia.org/wiki/Comb_sort\"; break;\r\n                            case \"selection_sort\": url = \"https://en.wikipedia.org/wiki/Selection_sort\"; break;\r\n                            case \"insertion_sort\": url = \"https://en.wikipedia.org/wiki/Insertion_sort\"; break;\r\n                            case \"gnome_sort\": url = \"https://en.wikipedia.org/wiki/Gnome_sort\"; break;\r\n                            case \"cycle_sort\": url = \"https://en.wikipedia.org/wiki/Cycle_sort\"; break;\r\n                            case \"sheel_sort\": url = \"https://en.wikipedia.org/wiki/Shellsort\"; break;\r\n                            case \"tree_sort\": url = \"https://en.wikipedia.org/wiki/Tree_sort\"; break;\r\n                            case \"bogo_sort\": url = \"https://en.wikipedia.org/wiki/Bogosort\"; break;\r\n                            case \"slow_sort\": url = \"https://en.wikipedia.org/wiki/Slowsort\"; break;\r\n                            case \"heap_sort\": url = \"https://en.wikipedia.org/wiki/Heapsort\"; break;\r\n                            case \"strand_sort\": url = \"https://en.wikipedia.org/wiki/Strand_sort\"; break;\r\n                            case \"stooge_sort\": url = \"https://en.wikipedia.org/wiki/Stooge_sort\"; break;\r\n                            case \"bead_sort\": url = \"https://en.wikipedia.org/wiki/Bead_sort\"; break;\r\n                            case \"pancake_sort\": url = \"https://en.wikipedia.org/wiki/Pancake_sorting\"; break;\r\n                            case \"pigeonhole_sort\": url = \"https://en.wikipedia.org/wiki/Pigeonhole_sort\"; break;\r\n                            case \"radix_sort\": url = \"https://en.wikipedia.org/wiki/Radix_sort\"; break;\r\n                            case \"quick_sort\": url = \"https://en.wikipedia.org/wiki/Quicksort\"; break;\r\n                            case \"merge_sort\": url = \"https://en.wikipedia.org/wiki/Merge_sort\"; break;\r\n                            default: break;\r\n                        }\r\n                        if (url) window.open(url);\r\n                    }}>\r\n                    ?\r\n                </button>\r\n\r\n                <div className=\"separator\" />\r\n\r\n                <label\r\n                    style={{ textAlign: \"center\" }}\r\n                    className=\"centered-item text-box\">\r\n                    Animation<br />speed\r\n                </label>\r\n                <input\r\n                    name=\"speed-control\"\r\n                    type=\"range\"\r\n                    style={{ width: \"100px\" }}\r\n                    min={CONSTS.MIN_ANIMATION_SPEED}\r\n                    max={CONSTS.MAX_ANIMATION_SPEED}\r\n                    defaultValue={CONSTS.INIT_ANIMATION_SPEED} />\r\n\r\n                <div className=\"separator\" />\r\n\r\n                <button\r\n                    className={idle ? \"sort-button\" : \"sort-button stop-button\"}\r\n                    onClick={() => {\r\n                        if (idle) {\r\n                            let e = this.state.selectRef.current;\r\n                            this.props.startSortActivated(e.options[e.selectedIndex].value);\r\n                        }\r\n                        else {\r\n                            this.props.stopSortActivated();\r\n                        }\r\n\r\n                        this.setState({\r\n                            selectRef: this.state.selectRef,\r\n                            isSorting: idle\r\n                        });\r\n                    }}>\r\n                    <span>{idle ? \"Start sorting\" : \"Stop\"}</span>\r\n                </button>\r\n            </div>\r\n        );\r\n    }\r\n\r\n}","import React from 'react'\r\nimport './SortingVisualizer.css'\r\nimport Body from './Body/Body'\r\nimport ToolBar from './ToolBar/ToolBar'\r\n\r\nexport default class SortingVisualizer extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            bodyRef: React.createRef(),\r\n            toolBarRef: React.createRef()\r\n        };\r\n    }\r\n\r\n    render() {\r\n        var ratio = 90; // [0 - 100]\r\n        return (\r\n            <div className=\"main-window\">\r\n                <div style={{ height: `${ratio}vh` }}>\r\n                    <Body\r\n                        ref={this.state.bodyRef}\r\n                        sortingCompleted={() => this.state.toolBarRef.current.sortingCompleted()} />\r\n                </div>\r\n                <div style={{ height: `${100 - ratio}vh` }}>\r\n                    <ToolBar\r\n                        ref={this.state.toolBarRef}\r\n                        handleRangeChanged={(n) => this.state.bodyRef.current.setNumberOfBars(n)}\r\n                        startSortActivated={(m) => this.state.bodyRef.current.sortArray(m)}\r\n                        stopSortActivated={() => this.state.bodyRef.current.stopSorting()} />\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}","import React from 'react';\nimport SortingVisualizer from './SortingVisualizer/SortingVisualizer'\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <SortingVisualizer />\n    </div>);\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();"],"sourceRoot":""}